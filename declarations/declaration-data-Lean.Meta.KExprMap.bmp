{"name":"Lean.Meta.KExprMap","instances":[{"typeNames":["Lean.Meta.KExprMap"],"name":"Lean.Meta.instInhabitedKExprMap","className":"Inhabited"}],"imports":["Init","Lean.HeadIndex","Lean.Meta.Basic"],"declarations":[{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Meta/KExprMap.lean#L41-L45","name":"Lean.Meta.KExprMap.insert","kind":"def","docLink":"./Lean/Meta/KExprMap.html#Lean.Meta.KExprMap.insert","doc":"Insert `e ↦ v` into `m` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Meta/KExprMap.lean#L22-L29","name":"Lean.Meta.KExprMap.find?","kind":"def","docLink":"./Lean/Meta/KExprMap.html#Lean.Meta.KExprMap.find?","doc":"Return `some v` if there is an entry `e ↦ v` in `m`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Meta/KExprMap.lean#L19-L19","name":"Lean.Meta.instInhabitedKExprMap","kind":"instance","docLink":"./Lean/Meta/KExprMap.html#Lean.Meta.instInhabitedKExprMap","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Meta/KExprMap.lean#L18-L18","name":"Lean.Meta.KExprMap.map","kind":"def","docLink":"./Lean/Meta/KExprMap.html#Lean.Meta.KExprMap.map","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Meta/KExprMap.lean#L17-L17","name":"Lean.Meta.KExprMap.mk","kind":"ctor","docLink":"./Lean/Meta/KExprMap.html#Lean.Meta.KExprMap.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Meta/KExprMap.lean#L17-L19","name":"Lean.Meta.KExprMap","kind":"structure","docLink":"./Lean/Meta/KExprMap.html#Lean.Meta.KExprMap","doc":"A mapping that indentifies definitionally equal expressions.\nWe implement it as a mapping from `HeadIndex` to `AssocList Expr α`.\n\nRemark: this map may be quite inefficient if there are many `HeadIndex` collisions.\n"}]}