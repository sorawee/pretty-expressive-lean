{"name":"Lean.Elab.Tactic.ElabTerm","instances":[],"imports":["Init","Lean.Meta.Tactic.Constructor","Lean.Meta.Tactic.Assert","Lean.Meta.Tactic.Clear","Lean.Meta.Tactic.Rename","Lean.Elab.Tactic.Basic","Lean.Elab.SyntheticMVars"],"declarations":[{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/Tactic/ElabTerm.lean#L370-L377","name":"Lean.Elab.Tactic.evalNativeDecide","kind":"def","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.evalNativeDecide","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/Tactic/ElabTerm.lean#L347-L357","name":"Lean.Elab.Tactic.evalDecide","kind":"def","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.evalDecide","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/Tactic/ElabTerm.lean#L318-L333","name":"Lean.Elab.Tactic.evalRename","kind":"def","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.evalRename","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/Tactic/ElabTerm.lean#L300-L316","name":"Lean.Elab.Tactic.elabAsFVar","kind":"def","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.elabAsFVar","doc":"Elaborate `stx`. If it a free variable, return it. Otherwise, assert it, and return the free variable.\nNote that, the main goal is updated when `Meta.assert` is used in the second case. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/Tactic/ElabTerm.lean#L294-L295","name":"Lean.Elab.Tactic.evalWithUnfoldingAll","kind":"def","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.evalWithUnfoldingAll","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/Tactic/ElabTerm.lean#L291-L292","name":"Lean.Elab.Tactic.evalWithReducibleAndInstances","kind":"def","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.evalWithReducibleAndInstances","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/Tactic/ElabTerm.lean#L288-L289","name":"Lean.Elab.Tactic.evalWithReducible","kind":"def","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.evalWithReducible","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/Tactic/ElabTerm.lean#L282-L286","name":"Lean.Elab.Tactic.evalConstructor","kind":"def","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.evalConstructor","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/Tactic/ElabTerm.lean#L277-L280","name":"Lean.Elab.Tactic.evalApply","kind":"def","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.evalApply","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/Tactic/ElabTerm.lean#L257-L275","name":"Lean.Elab.Tactic.evalApplyLikeTactic","kind":"def","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.evalApplyLikeTactic","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/Tactic/ElabTerm.lean#L254-L255","name":"Lean.Elab.Tactic.getFVarIds","kind":"def","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.getFVarIds","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/Tactic/ElabTerm.lean#L246-L252","name":"Lean.Elab.Tactic.getFVarId","kind":"def","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.getFVarId","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/Tactic/ElabTerm.lean#L206-L244","name":"Lean.Elab.Tactic.elabTermForApply","kind":"def","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.elabTermForApply","doc":"Given a tactic\n```\napply f\n```\nwe want the `apply` tactic to create all metavariables. The following\ndefinition will return `@f` for `f`. That is, it will **not** create\nmetavariables for implicit arguments.\nA similar method is also used in Lean 3.\nThis method is useful when applying lemmas such as:\n```\ntheorem infLeRight {s t : Set α} : s ⊓ t ≤ t\n```\nwhere `s ≤ t` here is defined as\n```\n∀ {x : α}, x ∈ s → x ∈ t\n```\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/Tactic/ElabTerm.lean#L173-L186","name":"Lean.Elab.Tactic.evalSpecialize","kind":"def","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.evalSpecialize","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/Tactic/ElabTerm.lean#L168-L171","name":"Lean.Elab.Tactic.evalRefine'","kind":"def","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.evalRefine'","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/Tactic/ElabTerm.lean#L163-L166","name":"Lean.Elab.Tactic.evalRefine","kind":"def","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.evalRefine","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/Tactic/ElabTerm.lean#L152-L161","name":"Lean.Elab.Tactic.refineCore","kind":"def","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.refineCore","doc":"If `allowNaturalHoles == true`, then we allow the resultant expression to contain unassigned \"natural\" metavariables.\nRecall that \"natutal\" metavariables are created for explicit holes `_` and implicit arguments. They are meant to be\nfilled by typing constraints.\n\"Synthetic\" metavariables are meant to be filled by tactics and are usually created using the synthetic hole notation `?<hole-name>`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/Tactic/ElabTerm.lean#L145-L146","name":"Lean.Elab.Tactic.elabTermWithHoles","kind":"def","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.elabTermWithHoles","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/Tactic/ElabTerm.lean#L121-L143","name":"Lean.Elab.Tactic.withCollectingNewGoalsFrom.go","kind":"def","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.withCollectingNewGoalsFrom.go","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/Tactic/ElabTerm.lean#L92-L143","name":"Lean.Elab.Tactic.withCollectingNewGoalsFrom","kind":"def","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.withCollectingNewGoalsFrom","doc":"Execute `k`, and collect new \"holes\" in the resulting expression.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/Tactic/ElabTerm.lean#L86-L87","name":"Lean.Elab.Tactic.sortMVarIdsByIndex","kind":"def","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.sortMVarIdsByIndex","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/Tactic/ElabTerm.lean#L76-L84","name":"Lean.Elab.Tactic.sortMVarIdArrayByIndex","kind":"def","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.sortMVarIdArrayByIndex","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/Tactic/ElabTerm.lean#L67-L74","name":"Lean.Elab.Tactic.evalExact","kind":"def","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.evalExact","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/Tactic/ElabTerm.lean#L63-L65","name":"Lean.Elab.Tactic.filterOldMVars","kind":"def","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.filterOldMVars","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/Tactic/ElabTerm.lean#L59-L61","name":"Lean.Elab.Tactic.logUnassignedAndAbort","kind":"def","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.logUnassignedAndAbort","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/Tactic/ElabTerm.lean#L55-L57","name":"Lean.Elab.Tactic.closeMainGoalUsing","kind":"def","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.closeMainGoalUsing","doc":"Try to close main goal using `x target`, where `target` is the type of the main goal.  "},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/Tactic/ElabTerm.lean#L41-L52","name":"Lean.Elab.Tactic.elabTermEnsuringType","kind":"def","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.elabTermEnsuringType","doc":"Elaborate `stx` in the current `MVarContext`. If given, the `expectedType` will be used to help\nelaboration and then a `TypeMismatchError` will be thrown if the elaborated type doesn't match.  "},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/Tactic/ElabTerm.lean#L35-L37","name":"Lean.Elab.Tactic.elabTerm","kind":"def","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.elabTerm","doc":"Elaborate `stx` in the current `MVarContext`. If given, the `expectedType` will be used to help\nelaboration but not enforced (use `elabTermEnsuringType` to enforce an expected type). "},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/Tactic/ElabTerm.lean#L31-L31","name":"Lean.Elab.Tactic.runTermElab.go","kind":"def","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.runTermElab.go","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/Tactic/ElabTerm.lean#L24-L31","name":"Lean.Elab.Tactic.runTermElab","kind":"def","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.runTermElab","doc":"Runs a term elaborator inside a tactic.\n\nThis function ensures that term elaboration fails when backtracking,\ni.e., in `first| tac term | other`.\n"}]}