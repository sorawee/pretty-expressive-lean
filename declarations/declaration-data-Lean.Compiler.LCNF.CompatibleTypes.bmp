{"name":"Lean.Compiler.LCNF.CompatibleTypes","instances":[],"imports":["Init","Lean.Compiler.LCNF.InferType"],"declarations":[{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Compiler/LCNF/CompatibleTypes.lean#L137-L141","name":"Lean.Compiler.LCNF.InferType.compatibleTypes","kind":"def","docLink":"./Lean/Compiler/LCNF/CompatibleTypes.html#Lean.Compiler.LCNF.InferType.compatibleTypes","doc":"Return true if the LCNF types `a` and `b` are compatible.\nRemark: `a` and `b` can be type formers (e.g., `List`, or `fun (α : Type) => Nat → Nat × α`)\nRemark: We may need to eta-expand type formers to establish whether they are compatible or not.\nFor example, suppose we have\n```\nfun (x : B) => Id B ◾ ◾\nId B ◾\n```\nWe must eta-expand `Id B ◾` to `fun (x : B) => Id B ◾ x`. Note that, we use `x` instead of `◾` to\nmake the implementation simpler and skip the check whether `B` is a type former type. However,\nthis simplification should not affect correctness since `◾` is compatible with everything.\nRemark: see comment at `isErasedCompatible`.\nRemark: because of \"erasure confusion\" see note above, we assume `◾` (aka `lcErasure`) is compatible with everything.\nThis is a simplification. We used to use `isErasedCompatible`, but this only address item 1.\nFor item 2, we would have to modify the `toLCNFType` function and make sure a type former is erased if the expected\ntype is not always a type former (see `S.mk` type and example in the note above).\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Compiler/LCNF/CompatibleTypes.lean#L108-L117","name":"Lean.Compiler.LCNF.InferType.compatibleTypesFull.etaExpand?","kind":"def","docLink":"./Lean/Compiler/LCNF/CompatibleTypes.html#Lean.Compiler.LCNF.InferType.compatibleTypesFull.etaExpand?","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Compiler/LCNF/CompatibleTypes.lean#L73-L117","name":"Lean.Compiler.LCNF.InferType.compatibleTypesFull","kind":"opaque","docLink":"./Lean/Compiler/LCNF/CompatibleTypes.html#Lean.Compiler.LCNF.InferType.compatibleTypesFull","doc":"Complete check for `compatibleTypes`. It eta-expands type formers. See comment at `compatibleTypes`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Compiler/LCNF/CompatibleTypes.lean#L49-L68","name":"Lean.Compiler.LCNF.compatibleTypesQuick","kind":"opaque","docLink":"./Lean/Compiler/LCNF/CompatibleTypes.html#Lean.Compiler.LCNF.compatibleTypesQuick","doc":"Quick check for `compatibleTypes`. It is not monadic, but it is incomplete\nbecause it does not eta-expand type formers. See comment at `compatibleTypes`.\nRemark: if the result is `true`, then `a` and `b` are indeed compatible.\nIf it is `false`, we must use the full-check.\n"}]}