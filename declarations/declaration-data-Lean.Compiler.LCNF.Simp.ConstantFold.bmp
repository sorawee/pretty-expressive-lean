{"name":"Lean.Compiler.LCNF.Simp.ConstantFold","instances":[{"typeNames":["Nat"],"name":"Lean.Compiler.LCNF.Simp.ConstantFold.instLiteralNat","className":"Lean.Compiler.LCNF.Simp.ConstantFold.Literal"},{"typeNames":["String"],"name":"Lean.Compiler.LCNF.Simp.ConstantFold.instLiteralString","className":"Lean.Compiler.LCNF.Simp.ConstantFold.Literal"},{"typeNames":["Bool"],"name":"Lean.Compiler.LCNF.Simp.ConstantFold.instLiteralBool","className":"Lean.Compiler.LCNF.Simp.ConstantFold.Literal"},{"typeNames":["UInt8"],"name":"Lean.Compiler.LCNF.Simp.ConstantFold.instLiteralUInt8","className":"Lean.Compiler.LCNF.Simp.ConstantFold.Literal"},{"typeNames":["UInt16"],"name":"Lean.Compiler.LCNF.Simp.ConstantFold.instLiteralUInt16","className":"Lean.Compiler.LCNF.Simp.ConstantFold.Literal"},{"typeNames":["UInt32"],"name":"Lean.Compiler.LCNF.Simp.ConstantFold.instLiteralUInt32","className":"Lean.Compiler.LCNF.Simp.ConstantFold.Literal"},{"typeNames":["UInt64"],"name":"Lean.Compiler.LCNF.Simp.ConstantFold.instLiteralUInt64","className":"Lean.Compiler.LCNF.Simp.ConstantFold.Literal"},{"typeNames":["Char"],"name":"Lean.Compiler.LCNF.Simp.ConstantFold.instLiteralChar","className":"Lean.Compiler.LCNF.Simp.ConstantFold.Literal"}],"imports":["Init","Lean.Compiler.LCNF.CompilerM","Lean.Compiler.LCNF.InferType","Lean.Compiler.LCNF.PassManager"],"declarations":[{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L423-L424","name":"Lean.Compiler.LCNF.Simp.ConstantFold.foldConstants","kind":"def","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.foldConstants","doc":"Apply a list of default folders to `decl`\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L417-L418","name":"Lean.Compiler.LCNF.Simp.ConstantFold.getFolders","kind":"def","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.getFolders","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L413-L415","name":"Lean.Compiler.LCNF.Simp.ConstantFold.registerFolder","kind":"def","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.registerFolder","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L398-L411","name":"Lean.Compiler.LCNF.Simp.ConstantFold.folderExt","kind":"opaque","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.folderExt","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L396-L396","name":"Lean.Compiler.LCNF.Simp.ConstantFold.FolderEntry.folder","kind":"def","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.FolderEntry.folder","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L395-L396","name":"Lean.Compiler.LCNF.Simp.ConstantFold.FolderEntry","kind":"structure","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.FolderEntry","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L393-L393","name":"Lean.Compiler.LCNF.Simp.ConstantFold.FolderOleanEntry.folderDeclName","kind":"def","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.FolderOleanEntry.folderDeclName","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L392-L392","name":"Lean.Compiler.LCNF.Simp.ConstantFold.FolderOleanEntry.declName","kind":"def","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.FolderOleanEntry.declName","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L391-L393","name":"Lean.Compiler.LCNF.Simp.ConstantFold.FolderOleanEntry","kind":"structure","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.FolderOleanEntry","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L387-L389","name":"Lean.Compiler.LCNF.Simp.ConstantFold.builtinFolders","kind":"def","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.builtinFolders","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L368-L376","name":"Lean.Compiler.LCNF.Simp.ConstantFold.applyFolders","kind":"def","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.applyFolders","doc":"Apply all known folders to `decl`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L359-L363","name":"Lean.Compiler.LCNF.Simp.ConstantFold.stringFolders","kind":"def","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.stringFolders","doc":"All string folders.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L336-L354","name":"Lean.Compiler.LCNF.Simp.ConstantFold.relationFolders","kind":"def","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.relationFolders","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L312-L334","name":"Lean.Compiler.LCNF.Simp.ConstantFold.arithmeticFolders","kind":"def","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.arithmeticFolders","doc":"All arithmetic folders.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L306-L307","name":"Lean.Compiler.LCNF.Simp.ConstantFold.Folder.mulShift","kind":"def","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.Folder.mulShift","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L302-L304","name":"Lean.Compiler.LCNF.Simp.ConstantFold.higherOrderLiteralFolders","kind":"def","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.higherOrderLiteralFolders","doc":"Literal folders for higher order datastructures.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L296-L297","name":"Lean.Compiler.LCNF.Simp.ConstantFold.Folder.leftRightAnnihilator","kind":"def","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.Folder.leftRightAnnihilator","doc":"Provide a folder for an operation that has the same left and right annihilator.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L290-L291","name":"Lean.Compiler.LCNF.Simp.ConstantFold.Folder.leftRightNeutral","kind":"def","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.Folder.leftRightNeutral","doc":"Provide a folder for an operation that has the same left and right neutral element.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L278-L285","name":"Lean.Compiler.LCNF.Simp.ConstantFold.Folder.first","kind":"def","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.Folder.first","doc":"Pick the first folder out of `folders` that succeeds.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L266-L273","name":"Lean.Compiler.LCNF.Simp.ConstantFold.Folder.mulLhsShift","kind":"def","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.Folder.mulLhsShift","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L257-L264","name":"Lean.Compiler.LCNF.Simp.ConstantFold.Folder.mulRhsShift","kind":"def","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.Folder.mulRhsShift","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L248-L255","name":"Lean.Compiler.LCNF.Simp.ConstantFold.Folder.divShift","kind":"def","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.Folder.divShift","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L242-L246","name":"Lean.Compiler.LCNF.Simp.ConstantFold.Folder.rightAnnihilator","kind":"def","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.Folder.rightAnnihilator","doc":"Provide a folder for an operation with a right annihilator.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L233-L237","name":"Lean.Compiler.LCNF.Simp.ConstantFold.Folder.leftAnnihilator","kind":"def","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.Folder.leftAnnihilator","doc":"Provide a folder for an operation with a left annihilator.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L224-L228","name":"Lean.Compiler.LCNF.Simp.ConstantFold.Folder.rightNeutral","kind":"def","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.Folder.rightNeutral","doc":"Provide a folder for an operation with a right neutral element.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L215-L219","name":"Lean.Compiler.LCNF.Simp.ConstantFold.Folder.leftNeutral","kind":"def","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.Folder.leftNeutral","doc":"Provide a folder for an operation with a left neutral element.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L203-L210","name":"Lean.Compiler.LCNF.Simp.ConstantFold.Folder.mkBinaryDecisionProcedure","kind":"def","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.Folder.mkBinaryDecisionProcedure","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L197-L201","name":"Lean.Compiler.LCNF.Simp.ConstantFold.Folder.mkBinary","kind":"def","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.Folder.mkBinary","doc":"Turn a binary function such as `Nat.add` into a constant folder.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L188-L192","name":"Lean.Compiler.LCNF.Simp.ConstantFold.Folder.mkUnary","kind":"def","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.Folder.mkUnary","doc":"Turn a unary function such as `Nat.succ` into a constant folder.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L178-L183","name":"Lean.Compiler.LCNF.Simp.ConstantFold.foldArrayLiteral","kind":"def","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.foldArrayLiteral","doc":"Evaluate array literals at compile time, that is turn:\n```\nlet _x.1 := @List.nil _\nlet _x.2 := @List.cons _ z _x.1\nlet _x.3 := @List.cons _ y _x.2\nlet _x.4 := @List.cons _ x _x.3\nlet _x.5 := @List.toArray _ _x.4\n```\nTo its array form:\n```\nlet _x.12 := 3\nlet _x.8 := @Array.mkEmpty _ _x.12\nlet _x.22 := @Array.push _ _x.8 x\nlet _x.24 := @Array.push _ _x.22 y\nlet _x.26 := @Array.push _ _x.24 z\n```\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L153-L158","name":"Lean.Compiler.LCNF.Simp.ConstantFold.mkPseudoArrayLiteral","kind":"def","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.mkPseudoArrayLiteral","doc":"Turn an `#[a, b, c]` into:\n```\nlet _x.12 := 3\nlet _x.8 := @Array.mkEmpty _ _x.12\nlet _x.22 := @Array.push _ _x.8 x\nlet _x.24 := @Array.push _ _x.22 y\nlet _x.26 := @Array.push _ _x.24 z\n_x.26\n```\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L133-L140","name":"Lean.Compiler.LCNF.Simp.ConstantFold.getPseudoListLiteral.go","kind":"opaque","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.getPseudoListLiteral.go","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L130-L140","name":"Lean.Compiler.LCNF.Simp.ConstantFold.getPseudoListLiteral","kind":"def","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.getPseudoListLiteral","doc":"Turns an expression chain of the form\n```\nlet _x.1 := @List.nil _\nlet _x.2 := @List.cons _ a _x.1\nlet _x.3 := @List.cons _ b _x.2\nlet _x.4 := @List.cons _ c _x.3\nlet _x.5 := @List.cons _ d _x.4\nlet _x.6 := @List.cons _ e _x.5\n```\ninto: `[a, b, c, d ,e]` + The type contained in the list\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L114-L114","name":"Lean.Compiler.LCNF.Simp.ConstantFold.instLiteralChar","kind":"instance","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.instLiteralChar","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L113-L113","name":"Lean.Compiler.LCNF.Simp.ConstantFold.instLiteralUInt64","kind":"instance","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.instLiteralUInt64","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L112-L112","name":"Lean.Compiler.LCNF.Simp.ConstantFold.instLiteralUInt32","kind":"instance","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.instLiteralUInt32","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L111-L111","name":"Lean.Compiler.LCNF.Simp.ConstantFold.instLiteralUInt16","kind":"instance","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.instLiteralUInt16","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L110-L110","name":"Lean.Compiler.LCNF.Simp.ConstantFold.instLiteralUInt8","kind":"instance","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.instLiteralUInt8","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L104-L108","name":"Lean.Compiler.LCNF.Simp.ConstantFold.mkNatWrapperInstance","kind":"def","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.mkNatWrapperInstance","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L94-L96","name":"Lean.Compiler.LCNF.Simp.ConstantFold.instLiteralBool","kind":"instance","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.instLiteralBool","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L90-L92","name":"Lean.Compiler.LCNF.Simp.ConstantFold.mkBoolLit","kind":"def","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.mkBoolLit","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L86-L88","name":"Lean.Compiler.LCNF.Simp.ConstantFold.getBoolLit","kind":"def","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.getBoolLit","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L82-L84","name":"Lean.Compiler.LCNF.Simp.ConstantFold.instLiteralString","kind":"instance","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.instLiteralString","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L79-L80","name":"Lean.Compiler.LCNF.Simp.ConstantFold.mkStringLit","kind":"def","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.mkStringLit","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L75-L77","name":"Lean.Compiler.LCNF.Simp.ConstantFold.getStringLit","kind":"def","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.getStringLit","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L71-L73","name":"Lean.Compiler.LCNF.Simp.ConstantFold.instLiteralNat","kind":"instance","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.instLiteralNat","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L68-L69","name":"Lean.Compiler.LCNF.Simp.ConstantFold.mkNatLit","kind":"def","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.mkNatLit","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L64-L66","name":"Lean.Compiler.LCNF.Simp.ConstantFold.getNatLit","kind":"def","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.getNatLit","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L60-L62","name":"Lean.Compiler.LCNF.Simp.ConstantFold.mkAuxLit","kind":"def","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.mkAuxLit","doc":"A wrapper around `mkAuxLetDecl` that also calls `mkLit`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L50-L53","name":"Lean.Compiler.LCNF.Simp.ConstantFold.mkAuxLetDecl","kind":"def","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.mkAuxLetDecl","doc":"A wrapper around `LCNF.mkAuxLetDecl` that will automatically store the\n`LetDecl` in the state of `FolderM`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L42-L42","name":"Lean.Compiler.LCNF.Simp.ConstantFold.Literal.mkLit","kind":"def","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.Literal.mkLit","doc":"Turn a value of type `α` into a series of auxiliary `LetDecl`s + a\nfinal `Expr` putting them all together into a literal of type `α`,\nwhere again the idea of what a literal is depends on `α`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L36-L36","name":"Lean.Compiler.LCNF.Simp.ConstantFold.Literal.getLit","kind":"def","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.Literal.getLit","doc":"Attempt to turn the provided `Expr` into a value of type `α` if\nit is whatever concept of a literal `α` has. Note that this function\ndoes assume that the provided `Expr` does indeed have type `α`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L30-L30","name":"Lean.Compiler.LCNF.Simp.ConstantFold.Literal.mk","kind":"ctor","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.Literal.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L30-L42","name":"Lean.Compiler.LCNF.Simp.ConstantFold.Literal","kind":"class","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.Literal","doc":"A typeclass for detecting and producing literals of arbitrary types\ninside of LCNF.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L24-L24","name":"Lean.Compiler.LCNF.Simp.ConstantFold.Folder","kind":"def","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.Folder","doc":"A constant folder for a specific function, takes all the arguments of a\ncertain function and produces a new `Expr` + auxiliary declarations in\nthe `FolderM` monad on success. If the folding fails it returns `none`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L17-L17","name":"Lean.Compiler.LCNF.Simp.ConstantFold.FolderM","kind":"def","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.FolderM","doc":"A constant folding monad, the additional state stores auxiliary declarations\nrequired to build the new constant.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L1-L1","name":"Lean.Compiler.LCNF.Simp.ConstantFold.FolderOleanEntry.mk","kind":"ctor","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.FolderOleanEntry.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Compiler/LCNF/Simp/ConstantFold.lean#L1-L1","name":"Lean.Compiler.LCNF.Simp.ConstantFold.FolderEntry.mk","kind":"ctor","docLink":"./Lean/Compiler/LCNF/Simp/ConstantFold.html#Lean.Compiler.LCNF.Simp.ConstantFold.FolderEntry.mk","doc":""}]}