{"name":"Lean.Elab.PreDefinition.Structural.Basic","instances":[{"typeNames":["Lean.Elab.Structural.M"],"name":"Lean.Elab.Structural.instInhabitedM","className":"Inhabited"}],"imports":["Init","Lean.Meta.Basic","Lean.Meta.ForEachExpr"],"declarations":[{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/PreDefinition/Structural/Basic.lean#L61-L64","name":"Lean.Elab.Structural.recArgHasLooseBVarsAt","kind":"def","docLink":"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.recArgHasLooseBVarsAt","doc":"Return true iff `e` contains an application `recFnName .. t ..` where the term `t` is\nthe argument we are trying to recurse on, and it contains loose bound variables.\n\nWe use this test to decide whether we should process a matcher-application as a regular\napplicaton or not. That is, whether we should push the `below` argument should be affected by the matcher or not.\nIf `e` does not contain an application of the form `recFnName .. t ..`, then we know\nthe recursion doesn't depend on any pattern variable in this matcher.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/PreDefinition/Structural/Basic.lean#L49-L50","name":"Lean.Elab.Structural.run","kind":"def","docLink":"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.run","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/PreDefinition/Structural/Basic.lean#L46-L47","name":"Lean.Elab.Structural.instInhabitedM","kind":"instance","docLink":"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.instInhabitedM","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/PreDefinition/Structural/Basic.lean#L44-L44","name":"Lean.Elab.Structural.M","kind":"def","docLink":"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.M","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/PreDefinition/Structural/Basic.lean#L42-L42","name":"Lean.Elab.Structural.State.addMatchers","kind":"def","docLink":"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.State.addMatchers","doc":"As part of the inductive predicates case, we keep adding more and more discriminants from the\nlocal context and build up a bigger matcher application until we reach a fixed point.\nAs a side-effect, this creates matchers. Here we capture all these side-effects, because\nthe construction rolls back any changes done to the environment and the side-effects\nneed to be replayed. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/PreDefinition/Structural/Basic.lean#L36-L42","name":"Lean.Elab.Structural.State","kind":"structure","docLink":"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.State","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/PreDefinition/Structural/Basic.lean#L33-L34","name":"Lean.Elab.Structural.RecArgInfo.recArgPos","kind":"def","docLink":"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.RecArgInfo.recArgPos","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/PreDefinition/Structural/Basic.lean#L31-L31","name":"Lean.Elab.Structural.RecArgInfo.indPred","kind":"def","docLink":"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.RecArgInfo.indPred","doc":"true if the type is an inductive predicate "},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/PreDefinition/Structural/Basic.lean#L29-L29","name":"Lean.Elab.Structural.RecArgInfo.reflexive","kind":"def","docLink":"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.RecArgInfo.reflexive","doc":"true if we are recursing over a reflexive inductive datatype "},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/PreDefinition/Structural/Basic.lean#L27-L27","name":"Lean.Elab.Structural.RecArgInfo.indIndices","kind":"def","docLink":"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.RecArgInfo.indIndices","doc":"inductive datatype indices of the argument we are recursing on, it is equal to `indicesPos.map fun i => ys.get! i` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/PreDefinition/Structural/Basic.lean#L25-L25","name":"Lean.Elab.Structural.RecArgInfo.indParams","kind":"def","docLink":"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.RecArgInfo.indParams","doc":"inductive datatype parameters of the argument we are recursing on "},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/PreDefinition/Structural/Basic.lean#L23-L23","name":"Lean.Elab.Structural.RecArgInfo.indLevels","kind":"def","docLink":"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.RecArgInfo.indLevels","doc":"inductive datatype universe levels of the argument we are recursing on "},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/PreDefinition/Structural/Basic.lean#L21-L21","name":"Lean.Elab.Structural.RecArgInfo.indName","kind":"def","docLink":"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.RecArgInfo.indName","doc":"inductive datatype name of the argument we are recursing on "},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/PreDefinition/Structural/Basic.lean#L19-L19","name":"Lean.Elab.Structural.RecArgInfo.indicesPos","kind":"def","docLink":"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.RecArgInfo.indicesPos","doc":"position in `ys` of the inductive datatype indices we are recursing on "},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/PreDefinition/Structural/Basic.lean#L17-L17","name":"Lean.Elab.Structural.RecArgInfo.pos","kind":"def","docLink":"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.RecArgInfo.pos","doc":"position in `ys` of the argument we are recursing on "},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/PreDefinition/Structural/Basic.lean#L15-L15","name":"Lean.Elab.Structural.RecArgInfo.ys","kind":"def","docLink":"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.RecArgInfo.ys","doc":"recursion arguments "},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/PreDefinition/Structural/Basic.lean#L13-L13","name":"Lean.Elab.Structural.RecArgInfo.fixedParams","kind":"def","docLink":"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.RecArgInfo.fixedParams","doc":"`fixedParams ++ ys` are the arguments of the function we are trying to justify termination using structural recursion. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/PreDefinition/Structural/Basic.lean#L11-L31","name":"Lean.Elab.Structural.RecArgInfo","kind":"structure","docLink":"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.RecArgInfo","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/PreDefinition/Structural/Basic.lean#L1-L1","name":"Lean.Elab.Structural.RecArgInfo.mk","kind":"ctor","docLink":"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.RecArgInfo.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/PreDefinition/Structural/Basic.lean#L1-L1","name":"Lean.Elab.Structural.State.mk","kind":"ctor","docLink":"./Lean/Elab/PreDefinition/Structural/Basic.html#Lean.Elab.Structural.State.mk","doc":""}]}