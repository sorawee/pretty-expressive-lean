{"name":"Lean.Meta.Match.Match","instances":[],"imports":["Init","Lean.Meta.Check","Lean.Meta.Closure","Lean.Meta.Tactic.Cases","Lean.Meta.Tactic.Contradiction","Lean.Meta.GeneralizeTelescope","Lean.Meta.Match.Basic"],"declarations":[{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Meta/Match/Match.lean#L955-L959","name":"Lean.Meta.MatcherApp.addArg?","kind":"def","docLink":"./Lean/Meta/Match/Match.html#Lean.Meta.MatcherApp.addArg?","doc":"Similar `MatcherApp.addArg?`, but returns `none` on failure. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Meta/Match/Match.lean#L919-L952","name":"Lean.Meta.MatcherApp.addArg","kind":"def","docLink":"./Lean/Meta/Match/Match.html#Lean.Meta.MatcherApp.addArg","doc":"Given\n- matcherApp `match_i As (fun xs => motive[xs]) discrs (fun ys_1 => (alt_1 : motive (C_1[ys_1])) ... (fun ys_n => (alt_n : motive (C_n[ys_n]) remaining`, and\n- expression `e : B[discrs]`,\nConstruct the term\n`match_i As (fun xs => B[xs] -> motive[xs]) discrs (fun ys_1 (y : B[C_1[ys_1]]) => alt_1) ... (fun ys_n (y : B[C_n[ys_n]]) => alt_n) e remaining`, and\nWe use `kabstract` to abstract the discriminants from `B[discrs]`.\nThis method assumes\n- the `matcherApp.motive` is a lambda abstraction where `xs.size == discrs.size`\n- each alternative is a lambda abstraction where `ys_i.size == matcherApp.altNumParams[i]`\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Meta/Match/Match.lean#L879-L887","name":"Lean.Meta.Match.withMkMatcherInput","kind":"def","docLink":"./Lean/Meta/Match/Match.html#Lean.Meta.Match.withMkMatcherInput","doc":"This function is only used for testing purposes "},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Meta/Match/Match.lean#L848-L876","name":"Lean.Meta.Match.getMkMatcherInputInContext","kind":"def","docLink":"./Lean/Meta/Match/Match.html#Lean.Meta.Match.getMkMatcherInputInContext","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Meta/Match/Match.lean#L753-L846","name":"Lean.Meta.Match.mkMatcher","kind":"def","docLink":"./Lean/Meta/Match/Match.html#Lean.Meta.Match.mkMatcher","doc":"Create a dependent matcher for `matchType` where `matchType` is of the form\n`(a_1 : A_1) -> (a_2 : A_2[a_1]) -> ... -> (a_n : A_n[a_1, a_2, ... a_{n-1}]) -> B[a_1, ..., a_n]`\nwhere `n = numDiscrs`, and the `lhss` are the left-hand-sides of the `match`-expression alternatives.\nEach `AltLHS` has a list of local declarations and a list of patterns.\nThe number of patterns must be the same in each `AltLHS`.\nThe generated matcher has the structure described at `MatcherInfo`. The motive argument is of the form\n`(motive : (a_1 : A_1) -> (a_2 : A_2[a_1]) -> ... -> (a_n : A_n[a_1, a_2, ... a_{n-1}]) -> Sort v)`\nwhere `v` is a universe parameter or 0 if `B[a_1, ..., a_n]` is a proposition. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Meta/Match/Match.lean#L736-L742","name":"Lean.Meta.Match.withCleanLCtxFor","kind":"def","docLink":"./Lean/Meta/Match/Match.html#Lean.Meta.Match.withCleanLCtxFor","doc":"Auxiliary method used at `mkMatcher`. It executes `k` in a local context that contains only\nthe local declarations `m` depends on. This is important because otherwise dependent elimination\nmay \"refine\" the types of unnecessary declarations and accidentally introduce unnecessary dependencies\nin the auto-generated auxiliary declaration. Note that this is not just an optimization because the\nunnecessary dependencies may prevent the termination checker from succeeding. For an example,\nsee issue #1237.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Meta/Match/Match.lean#L723-L726","name":"Lean.Meta.Match.MkMatcherInput.collectDependencies","kind":"def","docLink":"./Lean/Meta/Match/Match.html#Lean.Meta.Match.MkMatcherInput.collectDependencies","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Meta/Match/Match.lean#L719-L721","name":"Lean.Meta.Match.MkMatcherInput.collectFVars","kind":"def","docLink":"./Lean/Meta/Match/Match.html#Lean.Meta.Match.MkMatcherInput.collectFVars","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Meta/Match/Match.lean#L716-L717","name":"Lean.Meta.Match.MkMatcherInput.numDiscrs","kind":"def","docLink":"./Lean/Meta/Match/Match.html#Lean.Meta.Match.MkMatcherInput.numDiscrs","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Meta/Match/Match.lean#L714-L714","name":"Lean.Meta.Match.MkMatcherInput.lhss","kind":"def","docLink":"./Lean/Meta/Match/Match.html#Lean.Meta.Match.MkMatcherInput.lhss","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Meta/Match/Match.lean#L713-L713","name":"Lean.Meta.Match.MkMatcherInput.discrInfos","kind":"def","docLink":"./Lean/Meta/Match/Match.html#Lean.Meta.Match.MkMatcherInput.discrInfos","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Meta/Match/Match.lean#L712-L712","name":"Lean.Meta.Match.MkMatcherInput.matchType","kind":"def","docLink":"./Lean/Meta/Match/Match.html#Lean.Meta.Match.MkMatcherInput.matchType","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Meta/Match/Match.lean#L711-L711","name":"Lean.Meta.Match.MkMatcherInput.matcherName","kind":"def","docLink":"./Lean/Meta/Match/Match.html#Lean.Meta.Match.MkMatcherInput.matcherName","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Meta/Match/Match.lean#L710-L714","name":"Lean.Meta.Match.MkMatcherInput","kind":"structure","docLink":"./Lean/Meta/Match/Match.html#Lean.Meta.Match.MkMatcherInput","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Meta/Match/Match.lean#L682-L708","name":"Lean.Meta.Match.mkMatcherAuxDefinition","kind":"def","docLink":"./Lean/Meta/Match/Match.html#Lean.Meta.Match.mkMatcherAuxDefinition","doc":"Similar to `mkAuxDefinition`, but uses the cache `matcherExt`.\nIt also returns an Boolean that indicates whether a new matcher function was added to the environment or not. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Meta/Match/Match.lean#L678-L678","name":"Lean.Meta.Match.matcherExt","kind":"opaque","docLink":"./Lean/Meta/Match/Match.html#Lean.Meta.Match.matcherExt","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Meta/Match/Match.lean#L672-L676","name":"Lean.Meta.Match.bootstrap.genMatcherCode","kind":"opaque","docLink":"./Lean/Meta/Match/Match.html#Lean.Meta.Match.bootstrap.genMatcherCode","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Meta/Match/Match.lean#L603-L608","name":"Lean.Meta.Match.isCurrVarInductive","kind":"def","docLink":"./Lean/Meta/Match/Match.html#Lean.Meta.Match.isCurrVarInductive","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Meta/Match/Match.lean#L373-L390","name":"Lean.Meta.Match.processInaccessibleAsCtor","kind":"def","docLink":"./Lean/Meta/Match/Match.html#Lean.Meta.Match.processInaccessibleAsCtor","doc":"Given `alt` s.t. the next pattern is an inaccessible pattern `e`,\ntry to normalize `e` into a constructor application.\nIf it is not a constructor, throw an error.\nOtherwise, if it is a constructor application of `ctorName`,\nupdate the next patterns with the fields of the constructor.\nOtherwise, return none. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Meta/Match/Match.lean#L68-L68","name":"Lean.Meta.Match.State.counterExamples","kind":"def","docLink":"./Lean/Meta/Match/Match.html#Lean.Meta.Match.State.counterExamples","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Meta/Match/Match.lean#L67-L67","name":"Lean.Meta.Match.State.used","kind":"def","docLink":"./Lean/Meta/Match/Match.html#Lean.Meta.Match.State.used","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Meta/Match/Match.lean#L66-L68","name":"Lean.Meta.Match.State","kind":"structure","docLink":"./Lean/Meta/Match/Match.html#Lean.Meta.Match.State","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Meta/Match/Match.lean#L1-L1","name":"Lean.Meta.Match.MkMatcherInput.mk","kind":"ctor","docLink":"./Lean/Meta/Match/Match.html#Lean.Meta.Match.MkMatcherInput.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Meta/Match/Match.lean#L1-L1","name":"Lean.Meta.Match.State.mk","kind":"ctor","docLink":"./Lean/Meta/Match/Match.html#Lean.Meta.Match.State.mk","doc":""}]}