{"name":"Lean.Elab.Tactic.Induction","instances":[{"typeNames":["Lean.Elab.Tactic.ElimApp.Alt"],"name":"Lean.Elab.Tactic.ElimApp.instInhabitedAlt","className":"Inhabited"}],"imports":["Init","Lean.Util.CollectFVars","Lean.AuxRecursor","Lean.Parser.Term","Lean.Meta.RecursorInfo","Lean.Meta.CollectMVars","Lean.Meta.Tactic.ElimInfo","Lean.Meta.Tactic.Induction","Lean.Meta.Tactic.Cases","Lean.Meta.GeneralizeVars","Lean.Elab.App","Lean.Elab.Tactic.ElabTerm","Lean.Elab.Tactic.Generalize"],"declarations":[{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/Tactic/Induction.lean#L590-L616","name":"Lean.Elab.Tactic.evalCases","kind":"def","docLink":"./Lean/Elab/Tactic/Induction.html#Lean.Elab.Tactic.evalCases","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/Tactic/Induction.lean#L568-L588","name":"Lean.Elab.Tactic.elabCasesTargets","kind":"def","docLink":"./Lean/Elab/Tactic/Induction.html#Lean.Elab.Tactic.elabCasesTargets","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/Tactic/Induction.lean#L560-L566","name":"Lean.Elab.Tactic.evalInduction.checkTargets","kind":"def","docLink":"./Lean/Elab/Tactic/Induction.html#Lean.Elab.Tactic.evalInduction.checkTargets","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/Tactic/Induction.lean#L531-L566","name":"Lean.Elab.Tactic.evalInduction","kind":"def","docLink":"./Lean/Elab/Tactic/Induction.html#Lean.Elab.Tactic.evalInduction","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/Tactic/Induction.lean#L487-L493","name":"Lean.Elab.Tactic.getInductiveValFromMajor","kind":"def","docLink":"./Lean/Elab/Tactic/Induction.html#Lean.Elab.Tactic.getInductiveValFromMajor","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/Tactic/Induction.lean#L356-L360","name":"Lean.Elab.Tactic.ElimApp.evalAlts.applyPreTac","kind":"def","docLink":"./Lean/Elab/Tactic/Induction.html#Lean.Elab.Tactic.ElimApp.evalAlts.applyPreTac","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/Tactic/Induction.lean#L278-L355","name":"Lean.Elab.Tactic.ElimApp.evalAlts.go","kind":"def","docLink":"./Lean/Elab/Tactic/Induction.html#Lean.Elab.Tactic.ElimApp.evalAlts.go","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/Tactic/Induction.lean#L264-L360","name":"Lean.Elab.Tactic.ElimApp.evalAlts","kind":"def","docLink":"./Lean/Elab/Tactic/Induction.html#Lean.Elab.Tactic.ElimApp.evalAlts","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/Tactic/Induction.lean#L251-L262","name":"Lean.Elab.Tactic.ElimApp.reorderAlts","kind":"def","docLink":"./Lean/Elab/Tactic/Induction.html#Lean.Elab.Tactic.ElimApp.reorderAlts","doc":"If `altsSyntax` is not empty we reorder `alts` using the order the alternatives have been provided\nin `altsSyntax`. Motivations:\n\n1- It improves the effectiveness of the `checkpoint` and `save` tactics. Consider the following example:\n```lean\nexample (h₁ : p ∨ q) (h₂ : p → x = 0) (h₃ : q → y = 0) : x * y = 0 := by\n  cases h₁ with\n  | inr h =>\n    sleep 5000 -- sleeps for 5 seconds\n    save\n    have : y = 0 := h₃ h\n    -- We can confortably work here\n  | inl h => stop ...\n```\nIf we do reorder, the `inl` alternative will be executed first. Moreover, as we type in the `inr` alternative,\ntype errors will \"swallow\" the `inl` alternative and affect the tactic state at `save` making it ineffective.\n\n2- The errors are produced in the same order the appear in the code above. This is not super important when using IDEs.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/Tactic/Induction.lean#L186-L193","name":"Lean.Elab.Tactic.ElimApp.setMotiveArg","kind":"def","docLink":"./Lean/Elab/Tactic/Induction.html#Lean.Elab.Tactic.ElimApp.setMotiveArg","doc":"Given a goal `... targets ... |- C[targets]` associated with `mvarId`, assign\n`motiveArg := fun targets => C[targets]` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/Tactic/Induction.lean#L130-L168","name":"Lean.Elab.Tactic.ElimApp.mkElimApp.loop","kind":"opaque","docLink":"./Lean/Elab/Tactic/Induction.html#Lean.Elab.Tactic.ElimApp.mkElimApp.loop","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/Tactic/Induction.lean#L129-L182","name":"Lean.Elab.Tactic.ElimApp.mkElimApp","kind":"def","docLink":"./Lean/Elab/Tactic/Induction.html#Lean.Elab.Tactic.ElimApp.mkElimApp","doc":"Construct the an eliminator/recursor application. `targets` contains the explicit and implicit targets for\nthe eliminator. For example, the indices of builtin recursors are considered implicit targets.\nRemark: the method `addImplicitTargets` may be used to compute the sequence of implicit and explicit targets\nfrom the explicit ones.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/Tactic/Induction.lean#L121-L121","name":"Lean.Elab.Tactic.ElimApp.Result.others","kind":"def","docLink":"./Lean/Elab/Tactic/Induction.html#Lean.Elab.Tactic.ElimApp.Result.others","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/Tactic/Induction.lean#L120-L120","name":"Lean.Elab.Tactic.ElimApp.Result.alts","kind":"def","docLink":"./Lean/Elab/Tactic/Induction.html#Lean.Elab.Tactic.ElimApp.Result.alts","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/Tactic/Induction.lean#L119-L119","name":"Lean.Elab.Tactic.ElimApp.Result.elimApp","kind":"def","docLink":"./Lean/Elab/Tactic/Induction.html#Lean.Elab.Tactic.ElimApp.Result.elimApp","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/Tactic/Induction.lean#L118-L121","name":"Lean.Elab.Tactic.ElimApp.Result","kind":"structure","docLink":"./Lean/Elab/Tactic/Induction.html#Lean.Elab.Tactic.ElimApp.Result","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/Tactic/Induction.lean#L103-L103","name":"Lean.Elab.Tactic.ElimApp.M","kind":"def","docLink":"./Lean/Elab/Tactic/Induction.html#Lean.Elab.Tactic.ElimApp.M","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/Tactic/Induction.lean#L101-L101","name":"Lean.Elab.Tactic.ElimApp.State.insts","kind":"def","docLink":"./Lean/Elab/Tactic/Induction.html#Lean.Elab.Tactic.ElimApp.State.insts","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/Tactic/Induction.lean#L100-L100","name":"Lean.Elab.Tactic.ElimApp.State.alts","kind":"def","docLink":"./Lean/Elab/Tactic/Induction.html#Lean.Elab.Tactic.ElimApp.State.alts","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/Tactic/Induction.lean#L99-L99","name":"Lean.Elab.Tactic.ElimApp.State.fType","kind":"def","docLink":"./Lean/Elab/Tactic/Induction.html#Lean.Elab.Tactic.ElimApp.State.fType","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/Tactic/Induction.lean#L98-L98","name":"Lean.Elab.Tactic.ElimApp.State.f","kind":"def","docLink":"./Lean/Elab/Tactic/Induction.html#Lean.Elab.Tactic.ElimApp.State.f","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/Tactic/Induction.lean#L97-L97","name":"Lean.Elab.Tactic.ElimApp.State.targetPos","kind":"def","docLink":"./Lean/Elab/Tactic/Induction.html#Lean.Elab.Tactic.ElimApp.State.targetPos","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/Tactic/Induction.lean#L96-L96","name":"Lean.Elab.Tactic.ElimApp.State.argPos","kind":"def","docLink":"./Lean/Elab/Tactic/Induction.html#Lean.Elab.Tactic.ElimApp.State.argPos","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/Tactic/Induction.lean#L95-L101","name":"Lean.Elab.Tactic.ElimApp.State","kind":"structure","docLink":"./Lean/Elab/Tactic/Induction.html#Lean.Elab.Tactic.ElimApp.State","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/Tactic/Induction.lean#L93-L93","name":"Lean.Elab.Tactic.ElimApp.Context.targets","kind":"def","docLink":"./Lean/Elab/Tactic/Induction.html#Lean.Elab.Tactic.ElimApp.Context.targets","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/Tactic/Induction.lean#L92-L92","name":"Lean.Elab.Tactic.ElimApp.Context.elimInfo","kind":"def","docLink":"./Lean/Elab/Tactic/Induction.html#Lean.Elab.Tactic.ElimApp.Context.elimInfo","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/Tactic/Induction.lean#L91-L93","name":"Lean.Elab.Tactic.ElimApp.Context","kind":"structure","docLink":"./Lean/Elab/Tactic/Induction.html#Lean.Elab.Tactic.ElimApp.Context","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/Tactic/Induction.lean#L89-L89","name":"Lean.Elab.Tactic.ElimApp.instInhabitedAlt","kind":"instance","docLink":"./Lean/Elab/Tactic/Induction.html#Lean.Elab.Tactic.ElimApp.instInhabitedAlt","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/Tactic/Induction.lean#L88-L88","name":"Lean.Elab.Tactic.ElimApp.Alt.mvarId","kind":"def","docLink":"./Lean/Elab/Tactic/Induction.html#Lean.Elab.Tactic.ElimApp.Alt.mvarId","doc":"The subgoal metavariable for the alternative. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/Tactic/Induction.lean#L86-L86","name":"Lean.Elab.Tactic.ElimApp.Alt.declName?","kind":"def","docLink":"./Lean/Elab/Tactic/Induction.html#Lean.Elab.Tactic.ElimApp.Alt.declName?","doc":"A declaration corresponding to the inductive constructor.\n(For custom recursors, the alternatives correspond to parameter names in the\nrecursor, so we may not have a declaration to point to.)\nThis is used for go-to-definition on the alternative name. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/Tactic/Induction.lean#L81-L81","name":"Lean.Elab.Tactic.ElimApp.Alt.name","kind":"def","docLink":"./Lean/Elab/Tactic/Induction.html#Lean.Elab.Tactic.ElimApp.Alt.name","doc":"The short name of the alternative, used in `| foo =>` cases "},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/Tactic/Induction.lean#L79-L89","name":"Lean.Elab.Tactic.ElimApp.Alt","kind":"structure","docLink":"./Lean/Elab/Tactic/Induction.html#Lean.Elab.Tactic.ElimApp.Alt","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/Tactic/Induction.lean#L56-L72","name":"Lean.Elab.Tactic.evalAlt","kind":"def","docLink":"./Lean/Elab/Tactic/Induction.html#Lean.Elab.Tactic.evalAlt","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/Tactic/Induction.lean#L53-L54","name":"Lean.Elab.Tactic.isHoleRHS","kind":"def","docLink":"./Lean/Elab/Tactic/Induction.html#Lean.Elab.Tactic.isHoleRHS","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/Tactic/Induction.lean#L1-L1","name":"Lean.Elab.Tactic.ElimApp.Context.mk","kind":"ctor","docLink":"./Lean/Elab/Tactic/Induction.html#Lean.Elab.Tactic.ElimApp.Context.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/Tactic/Induction.lean#L1-L1","name":"Lean.Elab.Tactic.ElimApp.State.mk","kind":"ctor","docLink":"./Lean/Elab/Tactic/Induction.html#Lean.Elab.Tactic.ElimApp.State.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/Tactic/Induction.lean#L1-L1","name":"Lean.Elab.Tactic.ElimApp.Result.mk","kind":"ctor","docLink":"./Lean/Elab/Tactic/Induction.html#Lean.Elab.Tactic.ElimApp.Result.mk","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/3f6c5f17db30c2a2dcaca1b9e9faec4e2cf04b95/src/Lean/Elab/Tactic/Induction.lean#L1-L1","name":"Lean.Elab.Tactic.ElimApp.Alt.mk","kind":"ctor","docLink":"./Lean/Elab/Tactic/Induction.html#Lean.Elab.Tactic.ElimApp.Alt.mk","doc":""}]}